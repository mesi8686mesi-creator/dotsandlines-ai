<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ù†Ù‚Ø·Ù‡â€ŒØ®Ø· Û¶Ã—Û¶ Ø¨Ø§ AI ÙˆØ­Ø´ÛŒ</title>
  <style>
    body { margin:0; padding:0; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; }
    #game { margin-top:20px; touch-action: none; }
    #status { margin-top:10px; font-size: 18px; }
  </style>
</head>
<body>
  <h2>Ù†Ù‚Ø·Ù‡â€ŒØ®Ø· Û¶Ã—Û¶ â€” AI ÙˆØ­Ø´ÛŒ</h2>
  <canvas id="game" width="360" height="360"></canvas>
  <div id="status">Ù†ÙˆØ¨Øª Ø´Ù…Ø§Ø³Øª</div>

  <script>
    const SIZE = 6;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cellW = W / SIZE, cellH = H / SIZE;
    let hLines = Array(SIZE+1).fill().map(() => Array(SIZE).fill(false));
    let vLines = Array(SIZE).fill().map(() => Array(SIZE+1).fill(false));
    let scores = [0,0];
    let currentPlayer = 0; // 0 = human, 1 = AI
    const statusDiv = document.getElementById('status');

    function draw() {
      ctx.clearRect(0,0,W,H);
      // Ù†Ù‚Ø§Ø·
      ctx.fillStyle = 'black';
      for (let i=0;i<=SIZE;i++)
        for (let j=0;j<=SIZE;j++)
          ctx.beginPath(), ctx.arc(j*cellW, i*cellH, 4, 0,2*Math.PI), ctx.fill();

      // Ø®Ø·ÙˆØ· Ø§ÙÙ‚ÛŒ
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 3;
      for (let i=0;i<=SIZE;i++)
        for (let j=0;j<SIZE;j++)
          if (hLines[i][j])
            ctx.beginPath(), ctx.moveTo(j*cellW, i*cellH), ctx.lineTo((j+1)*cellW, i*cellH), ctx.stroke();

      // Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÛŒ
      for (let i=0;i<SIZE;i++)
        for (let j=0;j<=SIZE;j++)
          if (vLines[i][j])
            ctx.beginPath(), ctx.moveTo(j*cellW, i*cellH), ctx.lineTo(j*cellW, (i+1)*cellH), ctx.stroke();
    }

    function getLegalMoves() {
      const moves = [];
      for (let i=0;i<=SIZE;i++)
        for (let j=0;j<SIZE;j++)
          if (!hLines[i][j]) moves.push({horizontal:true, r:i, c:j});
      for (let i=0;i<SIZE;i++)
        for (let j=0;j<=SIZE;j++)
          if (!vLines[i][j]) moves.push({horizontal:false, r:i, c:j});
      return moves;
    }

    function applyMove(move) {
      if (move.horizontal) hLines[move.r][move.c] = true;
      else vLines[move.r][move.c] = true;
      let comp = checkCompleted(move);
      if (comp > 0) {
        scores[currentPlayer] += comp;
        // Ø¨Ø§Ø² Ù‡Ù… Ù‡Ù…ÛŒÙ† Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
      } else {
        currentPlayer = 1 - currentPlayer;
      }
    }

    function checkCompleted(move) {
      let cnt = 0;
      for (let di=-1; di<=0; di++) {
        for (let dj=-1; dj<=0; dj++) {
          let rr = move.r + di, cc = move.c + dj;
          if (rr>=0 && rr<SIZE && cc>=0 && cc<SIZE) {
            if (hLines[rr][cc] && hLines[rr+1][cc] && vLines[rr][cc] && vLines[rr][cc+1]) {
              cnt++;
            }
          }
        }
      }
      return cnt;
    }

    function isTerminal() {
      return getLegalMoves().length === 0;
    }

    function winner() {
      if (scores[0] > scores[1]) return 0;
      else if (scores[1] > scores[0]) return 1;
      else return -1;
    }

    function evaluate() {
      return scores[1] - scores[0];
    }

    function cloneState() {
      return {
        hLines: hLines.map(arr => arr.slice()),
        vLines: vLines.map(arr => arr.slice()),
        scores: scores.slice(),
        currentPlayer: currentPlayer
      };
    }

    function minimax(state, depth, maximizing) {
      if (depth === 0 || state.hLines.flat().every(x=>x) && state.vLines.flat().every(x=>x)) {
        return evaluate();
      }
      const moves = getLegalMovesFrom(state);
      if (maximizing) {
        let best = -Infinity;
        for (let m of moves) {
          let ns = applyToState(state, m);
          let val = minimax(ns, depth-1, false);
          best = Math.max(best, val);
        }
        return best;
      } else {
        let best = Infinity;
        for (let m of moves) {
          let ns = applyToState(state, m);
          let val = minimax(ns, depth-1, true);
          best = Math.min(best, val);
        }
        return best;
      }
    }

    function getLegalMovesFrom(s) {
      const moves = [];
      for (let i=0;i<=SIZE;i++)
        for (let j=0;j<SIZE;j++)
          if (!s.hLines[i][j]) moves.push({horizontal:true, r:i, c:j});
      for (let i=0;i<SIZE;i++)
        for (let j=0;j<=SIZE;j++)
          if (!s.vLines[i][j]) moves.push({horizontal:false, r:i, c:j});
      return moves;
    }

    function applyToState(s, m) {
      const ns = {
        hLines: s.hLines.map(arr=>arr.slice()),
        vLines: s.vLines.map(arr=>arr.slice()),
        scores: s.scores.slice(),
        currentPlayer: s.currentPlayer
      };
      if (m.horizontal) ns.hLines[m.r][m.c] = true;
      else ns.vLines[m.r][m.c] = true;
      let comp = checkCompletedIn(ns, m);
      if (comp > 0) {
        ns.scores[ns.currentPlayer] += comp;
      } else {
        ns.currentPlayer = 1 - ns.currentPlayer;
      }
      return ns;
    }

    function checkCompletedIn(s, move) {
      let cnt = 0;
      for (let di=-1; di<=0; di++) {
        for (let dj=-1; dj<=0; dj++) {
          let rr = move.r + di, cc = move.c + dj;
          if (rr>=0 && rr<SIZE && cc>=0 && cc<SIZE) {
            if (s.hLines[rr][cc] && s.hLines[rr+1][cc] && s.vLines[rr][cc] && s.vLines[rr][cc+1]) {
              cnt++;
            }
          }
        }
      }
      return cnt;
    }

    function aiMove() {
      const DEPTH = 4; // Ù…ÛŒ ØªÙˆÙ†ÛŒ 5 ÛŒØ§ 6 Ù‡Ù… Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒ Ø§Ú¯Ø± Ú¯ÙˆØ´ÛŒ Ù‚ÙˆÛŒ Ø¨Ø§Ø´Ù‡
      const moves = getLegalMoves();
      let best = null, bestVal = -Infinity;
      for (let m of moves) {
        let ns = applyToState(cloneState(), m);
        let val = minimax(ns, DEPTH, false);
        if (val > bestVal) {
          bestVal = val;
          best = m;
        }
      }
      return best;
    }

    canvas.addEventListener('touchstart', e => {
      if (currentPlayer !== 0) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      const row = Math.floor(y / cellH);
      const col = Math.floor(x / cellW);
      let candidate = { horizontal: true, r: row, c: col };
      applyMove(candidate);
      draw();

      if (!isTerminal()) {
        currentPlayer = 1;
        setTimeout(() => {
          const mv = aiMove();
          if (mv) {
            applyMove(mv);
            draw();
          }
          currentPlayer = 0;
        }, 300);
      }

      if (isTerminal()) {
        let w = winner();
        if (w === 0) statusDiv.textContent = "ØªÙˆ Ø¨Ø±Ø¯ÛŒ! ðŸŽ‰";
        else if (w === 1) statusDiv.textContent = "AI Ø¨Ø±Ø¯! ðŸ˜ˆ";
        else statusDiv.textContent = "Ù…Ø³Ø§ÙˆÛŒ Ø´Ø¯!";
      }
    });

    draw();
  </script>
</body>
</html>
